const moment = require('moment');

class RateLimitService {
  constructor(prisma, redis) {
    this.prisma = prisma;
    this.redis = redis;
    
    // Rate limit configurations for different endpoints
    this.limits = {
      // Price alerts - based on subscription tier
      price_alert: {
        FREE: { requests: 3, window: 30 * 24 * 60 * 60 * 1000 }, // 3 per month
        PREMIUM: { requests: 1000, window: 30 * 24 * 60 * 60 * 1000 }, // 1000 per month
        TEAM: { requests: 5000, window: 30 * 24 * 60 * 60 * 1000 } // 5000 per month
      },
      
      // Flight search API calls
      flight_search: {
        FREE: { requests: 50, window: 24 * 60 * 60 * 1000 }, // 50 per day
        PREMIUM: { requests: 500, window: 24 * 60 * 60 * 1000 }, // 500 per day
        TEAM: { requests: 2000, window: 24 * 60 * 60 * 1000 } // 2000 per day
      },
      
      // Trip creation
      trip_create: {
        FREE: { requests: 10, window: 24 * 60 * 60 * 1000 }, // 10 per day
        PREMIUM: { requests: 100, window: 24 * 60 * 60 * 1000 }, // 100 per day
        TEAM: { requests: 1000, window: 24 * 60 * 60 * 1000 } // 1000 per day
      },
      
      // External API calls (RapidAPI)
      external_api: {
        global: { requests: 10000, window: 24 * 60 * 60 * 1000 } // Global limit for all users
      }
    };
  }

  /**
   * Check if user can make a request to a specific endpoint
   * @param {string} userId - User ID
   * @param {string} endpoint - Endpoint name (e.g., 'price_alert', 'flight_search')
   * @param {string} tier - User subscription tier
   * @returns {Promise<{allowed: boolean, remaining: number, resetTime: Date}>}
   */
  async checkLimit(userId, endpoint, tier = 'FREE') {
    try {
      const config = this.limits[endpoint];
      if (!config) {
        throw new Error(`Unknown endpoint: ${endpoint}`);
      }

      const tierConfig = config[tier] || config.FREE;
      if (!tierConfig) {
        throw new Error(`Unknown tier: ${tier} for endpoint: ${endpoint}`);
      }

      const key = `rate_limit:${userId}:${endpoint}`;
      const now = Date.now();
      const windowStart = now - tierConfig.window;

      // Get current usage from Redis
      const usage = await this.redis.zCount(key, windowStart, now);
      
      const allowed = usage < tierConfig.requests;
      const remaining = Math.max(0, tierConfig.requests - usage);
      const resetTime = new Date(now + tierConfig.window);

      return {
        allowed,
        remaining,
        resetTime,
        limit: tierConfig.requests,
        window: tierConfig.window
      };

    } catch (error) {
      console.error('Rate limit check error:', error);
      // Fail open - allow request if there's an error
      return {
        allowed: true,
        remaining: 999,
        resetTime: new Date(Date.now() + 24 * 60 * 60 * 1000)
      };
    }
  }

  /**
   * Record a request for rate limiting
   * @param {string} userId - User ID
   * @param {string} endpoint - Endpoint name
   * @param {string} tier - User subscription tier
   * @returns {Promise<boolean>} - Success status
   */
  async recordRequest(userId, endpoint, tier = 'FREE') {
    try {
      const config = this.limits[endpoint];
      if (!config) {
        throw new Error(`Unknown endpoint: ${endpoint}`);
      }

      const tierConfig = config[tier] || config.FREE;
      const key = `rate_limit:${userId}:${endpoint}`;
      const now = Date.now();
      const windowStart = now - tierConfig.window;

      // Use Redis sorted set to track requests
      const pipeline = this.redis.multi();
      
      // Add current request
      pipeline.zAdd(key, { score: now, value: `${now}_${Math.random()}` });
      
      // Remove old requests outside the window
      pipeline.zRemRangeByScore(key, 0, windowStart);
      
      // Set expiration
      pipeline.expire(key, Math.ceil(tierConfig.window / 1000));
      
      await pipeline.exec();

      // Update database record for persistence
      await this.updateDatabaseRecord(userId, endpoint, tierConfig.window);

      return true;

    } catch (error) {
      console.error('Rate limit record error:', error);
      return false;
    }
  }

  /**
   * Update rate limit record in database for persistence
   * @param {string} userId - User ID
   * @param {string} endpoint - Endpoint name
   * @param {number} window - Time window in milliseconds
   */
  async updateDatabaseRecord(userId, endpoint, window) {
    try {
      const windowStart = new Date(Date.now() - window);

      await this.prisma.rateLimit.upsert({
        where: {
          userId_endpoint: {
            userId,
            endpoint
          }
        },
        update: {
          count: {
            increment: 1
          }
        },
        create: {
          userId,
          endpoint,
          count: 1,
          windowStart
        }
      });

    } catch (error) {
      console.error('Database rate limit update error:', error);
    }
  }

  /**
   * Get current rate limit status for a user across all endpoints
   * @param {string} userId - User ID
   * @param {string} tier - User subscription tier
   * @returns {Promise<Object>} - Rate limit status for all endpoints
   */
  async getUserLimitStatus(userId, tier = 'FREE') {
    const status = {};

    for (const endpoint of Object.keys(this.limits)) {
      if (endpoint === 'external_api') continue; // Skip global limits
      
      const limitStatus = await this.checkLimit(userId, endpoint, tier);
      status[endpoint] = limitStatus;
    }

    return status;
  }

  /**
   * Reset rate limits for a user (admin function)
   * @param {string} userId - User ID
   * @param {string} endpoint - Optional specific endpoint to reset
   */
  async resetUserLimits(userId, endpoint = null) {
    try {
      if (endpoint) {
        // Reset specific endpoint
        const key = `rate_limit:${userId}:${endpoint}`;
        await this.redis.del(key);
        
        await this.prisma.rateLimit.deleteMany({
          where: {
            userId,
            endpoint
          }
        });
      } else {
        // Reset all endpoints for user
        const keys = await this.redis.keys(`rate_limit:${userId}:*`);
        if (keys.length > 0) {
          await this.redis.del(keys);
        }
        
        await this.prisma.rateLimit.deleteMany({
          where: { userId }
        });
      }

      console.log(`âœ… Rate limits reset for user ${userId}${endpoint ? ` endpoint ${endpoint}` : ''}`);
      return true;

    } catch (error) {
      console.error('Rate limit reset error:', error);
      return false;
    }
  }

  /**
   * Smart rate limiter for external API calls
   * Implements exponential backoff and request batching
   */
  class ExternalAPIRateLimiter {
    constructor(redis) {
      this.redis = redis;
      this.baseDelay = 1000; // 1 second
      this.maxDelay = 30000; // 30 seconds
      this.batchSize = 5;
      this.requestQueue = [];
      this.processing = false;
    }

    /**
     * Add request to queue with intelligent batching
     * @param {Function} requestFunction - Function that makes the API call
     * @param {Object} params - Request parameters
     * @returns {Promise} - Request result
     */
    async queueRequest(requestFunction, params) {
      return new Promise((resolve, reject) => {
        this.requestQueue.push({
          function: requestFunction,
          params,
          resolve,
          reject,
          timestamp: Date.now()
        });

        if (!this.processing) {
          this.processQueue();
        }
      });
    }

    /**
     * Process the request queue with rate limiting
     */
    async processQueue() {
      if (this.processing || this.requestQueue.length === 0) {
        return;
      }

      this.processing = true;

      while (this.requestQueue.length > 0) {
        // Get batch of requests
        const batch = this.requestQueue.splice(0, this.batchSize);
        
        // Check if we need to wait
        const delay = await this.getDelay();
        if (delay > 0) {
          await this.sleep(delay);
        }

        // Process batch
        await Promise.allSettled(
          batch.map(async (request) => {
            try {
              const result = await request.function(request.params);
              request.resolve(result);
            } catch (error) {
              request.reject(error);
            }
          })
        );

        // Record successful batch
        await this.recordBatch();
      }

      this.processing = false;
    }

    /**
     * Calculate delay based on recent request history
     * @returns {Promise<number>} - Delay in milliseconds
     */
    async getDelay() {
      try {
        const key = 'external_api_requests';
        const now = Date.now();
        const oneMinuteAgo = now - 60000;

        // Count requests in the last minute
        const recentRequests = await this.redis.zCount(key, oneMinuteAgo, now);
        
        // Implement exponential backoff if too many requests
        if (recentRequests > 50) { // More than 50 requests per minute
          const backoffMultiplier = Math.min(Math.floor(recentRequests / 50), 10);
          return this.baseDelay * Math.pow(2, backoffMultiplier);
        }

        return 0;

      } catch (error) {
        console.error('Get delay error:', error);
        return this.baseDelay; // Default delay on error
      }
    }

    /**
     * Record a successful batch execution
     */
    async recordBatch() {
      try {
        const key = 'external_api_requests';
        const now = Date.now();
        
        await this.redis.zAdd(key, { score: now, value: `batch_${now}` });
        
        // Clean up old entries (older than 1 hour)
        const oneHourAgo = now - 3600000;
        await this.redis.zRemRangeByScore(key, 0, oneHourAgo);
        
        await this.redis.expire(key, 3600); // 1 hour expiration

      } catch (error) {
        console.error('Record batch error:', error);
      }
    }

    /**
     * Sleep utility
     * @param {number} ms - Milliseconds to sleep
     */
    sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
  }

  /**
   * Create external API rate limiter instance
   * @returns {ExternalAPIRateLimiter}
   */
  createExternalAPILimiter() {
    return new this.ExternalAPIRateLimiter(this.redis);
  }

  /**
   * Clean up old rate limit records (run periodically)
   */
  async cleanup() {
    try {
      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
      
      // Clean up database records
      const deleted = await this.prisma.rateLimit.deleteMany({
        where: {
          windowStart: {
            lt: oneDayAgo
          }
        }
      });

      console.log(`ðŸ§¹ Cleaned up ${deleted.count} old rate limit records`);
      return deleted.count;

    } catch (error) {
      console.error('Rate limit cleanup error:', error);
      return 0;
    }
  }
}

module.exports = RateLimitService;